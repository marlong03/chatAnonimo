{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Polling = void 0;\n\nconst transport_1 = require(\"../transport\");\n\nconst zlib_1 = require(\"zlib\");\n\nconst accepts = require(\"accepts\");\n\nconst debug_1 = require(\"debug\");\n\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n  gzip: zlib_1.createGzip,\n  deflate: zlib_1.createDeflate\n};\n\nclass Polling extends transport_1.Transport {\n  /**\n   * HTTP polling constructor.\n   *\n   * @api public.\n   */\n  constructor(req) {\n    super(req);\n    this.closeTimeout = 30 * 1000;\n  }\n  /**\n   * Transport name\n   *\n   * @api public\n   */\n\n\n  get name() {\n    return \"polling\";\n  }\n\n  get supportsFraming() {\n    return false;\n  }\n  /**\n   * Overrides onRequest.\n   *\n   * @param {http.IncomingMessage}\n   * @api private\n   */\n\n\n  onRequest(req) {\n    const res = req.res;\n\n    if (\"GET\" === req.method) {\n      this.onPollRequest(req, res);\n    } else if (\"POST\" === req.method) {\n      this.onDataRequest(req, res);\n    } else {\n      res.writeHead(500);\n      res.end();\n    }\n  }\n  /**\n   * The client sends a request awaiting for us to send data.\n   *\n   * @api private\n   */\n\n\n  onPollRequest(req, res) {\n    if (this.req) {\n      debug(\"request overlap\"); // assert: this.res, '.req and .res should be (un)set together'\n\n      this.onError(\"overlap from client\");\n      res.writeHead(500);\n      res.end();\n      return;\n    }\n\n    debug(\"setting request\");\n    this.req = req;\n    this.res = res;\n\n    const onClose = () => {\n      this.onError(\"poll connection closed prematurely\");\n    };\n\n    const cleanup = () => {\n      req.removeListener(\"close\", onClose);\n      this.req = this.res = null;\n    };\n\n    req.cleanup = cleanup;\n    req.on(\"close\", onClose);\n    this.writable = true;\n    this.emit(\"drain\"); // if we're still writable but had a pending close, trigger an empty send\n\n    if (this.writable && this.shouldClose) {\n      debug(\"triggering empty send to append close packet\");\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n  }\n  /**\n   * The client sends a request with data.\n   *\n   * @api private\n   */\n\n\n  onDataRequest(req, res) {\n    if (this.dataReq) {\n      // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n      this.onError(\"data request overlap from client\");\n      res.writeHead(500);\n      res.end();\n      return;\n    }\n\n    const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n\n    if (isBinary && this.protocol === 4) {\n      return this.onError(\"invalid content\");\n    }\n\n    this.dataReq = req;\n    this.dataRes = res;\n    let chunks = isBinary ? Buffer.concat([]) : \"\";\n\n    const cleanup = () => {\n      req.removeListener(\"data\", onData);\n      req.removeListener(\"end\", onEnd);\n      req.removeListener(\"close\", onClose);\n      this.dataReq = this.dataRes = chunks = null;\n    };\n\n    const onClose = () => {\n      cleanup();\n      this.onError(\"data request connection closed prematurely\");\n    };\n\n    const onData = data => {\n      let contentLength;\n\n      if (isBinary) {\n        chunks = Buffer.concat([chunks, data]);\n        contentLength = chunks.length;\n      } else {\n        chunks += data;\n        contentLength = Buffer.byteLength(chunks);\n      }\n\n      if (contentLength > this.maxHttpBufferSize) {\n        res.writeHead(413).end();\n        cleanup();\n      }\n    };\n\n    const onEnd = () => {\n      this.onData(chunks);\n      const headers = {\n        // text/html is required instead of text/plain to avoid an\n        // unwanted download dialog on certain user-agents (GH-43)\n        \"Content-Type\": \"text/html\",\n        \"Content-Length\": 2\n      };\n      res.writeHead(200, this.headers(req, headers));\n      res.end(\"ok\");\n      cleanup();\n    };\n\n    req.on(\"close\", onClose);\n    if (!isBinary) req.setEncoding(\"utf8\");\n    req.on(\"data\", onData);\n    req.on(\"end\", onEnd);\n  }\n  /**\n   * Processes the incoming data payload.\n   *\n   * @param {String} encoded payload\n   * @api private\n   */\n\n\n  onData(data) {\n    debug('received \"%s\"', data);\n\n    const callback = packet => {\n      if (\"close\" === packet.type) {\n        debug(\"got xhr close packet\");\n        this.onClose();\n        return false;\n      }\n\n      this.onPacket(packet);\n    };\n\n    if (this.protocol === 3) {\n      this.parser.decodePayload(data, callback);\n    } else {\n      this.parser.decodePayload(data).forEach(callback);\n    }\n  }\n  /**\n   * Overrides onClose.\n   *\n   * @api private\n   */\n\n\n  onClose() {\n    if (this.writable) {\n      // close pending poll request\n      this.send([{\n        type: \"noop\"\n      }]);\n    }\n\n    super.onClose();\n  }\n  /**\n   * Writes a packet payload.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n\n\n  send(packets) {\n    this.writable = false;\n\n    if (this.shouldClose) {\n      debug(\"appending close packet to payload\");\n      packets.push({\n        type: \"close\"\n      });\n      this.shouldClose();\n      this.shouldClose = null;\n    }\n\n    const doWrite = data => {\n      const compress = packets.some(packet => {\n        return packet.options && packet.options.compress;\n      });\n      this.write(data, {\n        compress\n      });\n    };\n\n    if (this.protocol === 3) {\n      this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n    } else {\n      this.parser.encodePayload(packets, doWrite);\n    }\n  }\n  /**\n   * Writes data as response to poll request.\n   *\n   * @param {String} data\n   * @param {Object} options\n   * @api private\n   */\n\n\n  write(data, options) {\n    debug('writing \"%s\"', data);\n    this.doWrite(data, options, () => {\n      this.req.cleanup();\n    });\n  }\n  /**\n   * Performs the write.\n   *\n   * @api private\n   */\n\n\n  doWrite(data, options, callback) {\n    // explicit UTF-8 is required for pages not served under utf\n    const isString = typeof data === \"string\";\n    const contentType = isString ? \"text/plain; charset=UTF-8\" : \"application/octet-stream\";\n    const headers = {\n      \"Content-Type\": contentType\n    };\n\n    const respond = data => {\n      headers[\"Content-Length\"] = \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n      this.res.writeHead(200, this.headers(this.req, headers));\n      this.res.end(data);\n      callback();\n    };\n\n    if (!this.httpCompression || !options.compress) {\n      respond(data);\n      return;\n    }\n\n    const len = isString ? Buffer.byteLength(data) : data.length;\n\n    if (len < this.httpCompression.threshold) {\n      respond(data);\n      return;\n    }\n\n    const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n\n    if (!encoding) {\n      respond(data);\n      return;\n    }\n\n    this.compress(data, encoding, (err, data) => {\n      if (err) {\n        this.res.writeHead(500);\n        this.res.end();\n        callback(err);\n        return;\n      }\n\n      headers[\"Content-Encoding\"] = encoding;\n      respond(data);\n    });\n  }\n  /**\n   * Compresses data.\n   *\n   * @api private\n   */\n\n\n  compress(data, encoding, callback) {\n    debug(\"compressing\");\n    const buffers = [];\n    let nread = 0;\n    compressionMethods[encoding](this.httpCompression).on(\"error\", callback).on(\"data\", function (chunk) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }).on(\"end\", function () {\n      callback(null, Buffer.concat(buffers, nread));\n    }).end(data);\n  }\n  /**\n   * Closes the transport.\n   *\n   * @api private\n   */\n\n\n  doClose(fn) {\n    debug(\"closing\");\n    let closeTimeoutTimer;\n\n    if (this.dataReq) {\n      debug(\"aborting ongoing data request\");\n      this.dataReq.destroy();\n    }\n\n    const onClose = () => {\n      clearTimeout(closeTimeoutTimer);\n      fn();\n      this.onClose();\n    };\n\n    if (this.writable) {\n      debug(\"transport writable - closing right away\");\n      this.send([{\n        type: \"close\"\n      }]);\n      onClose();\n    } else if (this.discarded) {\n      debug(\"transport discarded - closing right away\");\n      onClose();\n    } else {\n      debug(\"transport not writable - buffering orderly close\");\n      this.shouldClose = onClose;\n      closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n    }\n  }\n  /**\n   * Returns headers for a response.\n   *\n   * @param {http.IncomingMessage} request\n   * @param {Object} extra headers\n   * @api private\n   */\n\n\n  headers(req, headers) {\n    headers = headers || {}; // prevent XSS warnings on IE\n    // https://github.com/LearnBoost/socket.io/pull/1333\n\n    const ua = req.headers[\"user-agent\"];\n\n    if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n      headers[\"X-XSS-Protection\"] = \"0\";\n    }\n\n    this.emit(\"headers\", headers, req);\n    return headers;\n  }\n\n}\n\nexports.Polling = Polling;","map":{"version":3,"names":["Object","defineProperty","exports","value","Polling","transport_1","require","zlib_1","accepts","debug_1","debug","default","compressionMethods","gzip","createGzip","deflate","createDeflate","Transport","constructor","req","closeTimeout","name","supportsFraming","onRequest","res","method","onPollRequest","onDataRequest","writeHead","end","onError","onClose","cleanup","removeListener","on","writable","emit","shouldClose","send","type","dataReq","isBinary","headers","protocol","dataRes","chunks","Buffer","concat","onData","onEnd","data","contentLength","length","byteLength","maxHttpBufferSize","setEncoding","callback","packet","onPacket","parser","decodePayload","forEach","packets","push","doWrite","compress","some","options","write","encodePayload","supportsBinary","isString","contentType","respond","httpCompression","len","threshold","encoding","encodings","err","buffers","nread","chunk","doClose","fn","closeTimeoutTimer","destroy","clearTimeout","discarded","setTimeout","ua","indexOf"],"sources":["C:/Users/SystemForLinux/Desktop/f2/code/chat/chatangular/node_modules/engine.io/build/transports/polling.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polling = void 0;\nconst transport_1 = require(\"../transport\");\nconst zlib_1 = require(\"zlib\");\nconst accepts = require(\"accepts\");\nconst debug_1 = require(\"debug\");\nconst debug = (0, debug_1.default)(\"engine:polling\");\nconst compressionMethods = {\n    gzip: zlib_1.createGzip,\n    deflate: zlib_1.createDeflate\n};\nclass Polling extends transport_1.Transport {\n    /**\n     * HTTP polling constructor.\n     *\n     * @api public.\n     */\n    constructor(req) {\n        super(req);\n        this.closeTimeout = 30 * 1000;\n    }\n    /**\n     * Transport name\n     *\n     * @api public\n     */\n    get name() {\n        return \"polling\";\n    }\n    get supportsFraming() {\n        return false;\n    }\n    /**\n     * Overrides onRequest.\n     *\n     * @param {http.IncomingMessage}\n     * @api private\n     */\n    onRequest(req) {\n        const res = req.res;\n        if (\"GET\" === req.method) {\n            this.onPollRequest(req, res);\n        }\n        else if (\"POST\" === req.method) {\n            this.onDataRequest(req, res);\n        }\n        else {\n            res.writeHead(500);\n            res.end();\n        }\n    }\n    /**\n     * The client sends a request awaiting for us to send data.\n     *\n     * @api private\n     */\n    onPollRequest(req, res) {\n        if (this.req) {\n            debug(\"request overlap\");\n            // assert: this.res, '.req and .res should be (un)set together'\n            this.onError(\"overlap from client\");\n            res.writeHead(500);\n            res.end();\n            return;\n        }\n        debug(\"setting request\");\n        this.req = req;\n        this.res = res;\n        const onClose = () => {\n            this.onError(\"poll connection closed prematurely\");\n        };\n        const cleanup = () => {\n            req.removeListener(\"close\", onClose);\n            this.req = this.res = null;\n        };\n        req.cleanup = cleanup;\n        req.on(\"close\", onClose);\n        this.writable = true;\n        this.emit(\"drain\");\n        // if we're still writable but had a pending close, trigger an empty send\n        if (this.writable && this.shouldClose) {\n            debug(\"triggering empty send to append close packet\");\n            this.send([{ type: \"noop\" }]);\n        }\n    }\n    /**\n     * The client sends a request with data.\n     *\n     * @api private\n     */\n    onDataRequest(req, res) {\n        if (this.dataReq) {\n            // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'\n            this.onError(\"data request overlap from client\");\n            res.writeHead(500);\n            res.end();\n            return;\n        }\n        const isBinary = \"application/octet-stream\" === req.headers[\"content-type\"];\n        if (isBinary && this.protocol === 4) {\n            return this.onError(\"invalid content\");\n        }\n        this.dataReq = req;\n        this.dataRes = res;\n        let chunks = isBinary ? Buffer.concat([]) : \"\";\n        const cleanup = () => {\n            req.removeListener(\"data\", onData);\n            req.removeListener(\"end\", onEnd);\n            req.removeListener(\"close\", onClose);\n            this.dataReq = this.dataRes = chunks = null;\n        };\n        const onClose = () => {\n            cleanup();\n            this.onError(\"data request connection closed prematurely\");\n        };\n        const onData = data => {\n            let contentLength;\n            if (isBinary) {\n                chunks = Buffer.concat([chunks, data]);\n                contentLength = chunks.length;\n            }\n            else {\n                chunks += data;\n                contentLength = Buffer.byteLength(chunks);\n            }\n            if (contentLength > this.maxHttpBufferSize) {\n                res.writeHead(413).end();\n                cleanup();\n            }\n        };\n        const onEnd = () => {\n            this.onData(chunks);\n            const headers = {\n                // text/html is required instead of text/plain to avoid an\n                // unwanted download dialog on certain user-agents (GH-43)\n                \"Content-Type\": \"text/html\",\n                \"Content-Length\": 2\n            };\n            res.writeHead(200, this.headers(req, headers));\n            res.end(\"ok\");\n            cleanup();\n        };\n        req.on(\"close\", onClose);\n        if (!isBinary)\n            req.setEncoding(\"utf8\");\n        req.on(\"data\", onData);\n        req.on(\"end\", onEnd);\n    }\n    /**\n     * Processes the incoming data payload.\n     *\n     * @param {String} encoded payload\n     * @api private\n     */\n    onData(data) {\n        debug('received \"%s\"', data);\n        const callback = packet => {\n            if (\"close\" === packet.type) {\n                debug(\"got xhr close packet\");\n                this.onClose();\n                return false;\n            }\n            this.onPacket(packet);\n        };\n        if (this.protocol === 3) {\n            this.parser.decodePayload(data, callback);\n        }\n        else {\n            this.parser.decodePayload(data).forEach(callback);\n        }\n    }\n    /**\n     * Overrides onClose.\n     *\n     * @api private\n     */\n    onClose() {\n        if (this.writable) {\n            // close pending poll request\n            this.send([{ type: \"noop\" }]);\n        }\n        super.onClose();\n    }\n    /**\n     * Writes a packet payload.\n     *\n     * @param {Object} packet\n     * @api private\n     */\n    send(packets) {\n        this.writable = false;\n        if (this.shouldClose) {\n            debug(\"appending close packet to payload\");\n            packets.push({ type: \"close\" });\n            this.shouldClose();\n            this.shouldClose = null;\n        }\n        const doWrite = data => {\n            const compress = packets.some(packet => {\n                return packet.options && packet.options.compress;\n            });\n            this.write(data, { compress });\n        };\n        if (this.protocol === 3) {\n            this.parser.encodePayload(packets, this.supportsBinary, doWrite);\n        }\n        else {\n            this.parser.encodePayload(packets, doWrite);\n        }\n    }\n    /**\n     * Writes data as response to poll request.\n     *\n     * @param {String} data\n     * @param {Object} options\n     * @api private\n     */\n    write(data, options) {\n        debug('writing \"%s\"', data);\n        this.doWrite(data, options, () => {\n            this.req.cleanup();\n        });\n    }\n    /**\n     * Performs the write.\n     *\n     * @api private\n     */\n    doWrite(data, options, callback) {\n        // explicit UTF-8 is required for pages not served under utf\n        const isString = typeof data === \"string\";\n        const contentType = isString\n            ? \"text/plain; charset=UTF-8\"\n            : \"application/octet-stream\";\n        const headers = {\n            \"Content-Type\": contentType\n        };\n        const respond = data => {\n            headers[\"Content-Length\"] =\n                \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n            this.res.writeHead(200, this.headers(this.req, headers));\n            this.res.end(data);\n            callback();\n        };\n        if (!this.httpCompression || !options.compress) {\n            respond(data);\n            return;\n        }\n        const len = isString ? Buffer.byteLength(data) : data.length;\n        if (len < this.httpCompression.threshold) {\n            respond(data);\n            return;\n        }\n        const encoding = accepts(this.req).encodings([\"gzip\", \"deflate\"]);\n        if (!encoding) {\n            respond(data);\n            return;\n        }\n        this.compress(data, encoding, (err, data) => {\n            if (err) {\n                this.res.writeHead(500);\n                this.res.end();\n                callback(err);\n                return;\n            }\n            headers[\"Content-Encoding\"] = encoding;\n            respond(data);\n        });\n    }\n    /**\n     * Compresses data.\n     *\n     * @api private\n     */\n    compress(data, encoding, callback) {\n        debug(\"compressing\");\n        const buffers = [];\n        let nread = 0;\n        compressionMethods[encoding](this.httpCompression)\n            .on(\"error\", callback)\n            .on(\"data\", function (chunk) {\n            buffers.push(chunk);\n            nread += chunk.length;\n        })\n            .on(\"end\", function () {\n            callback(null, Buffer.concat(buffers, nread));\n        })\n            .end(data);\n    }\n    /**\n     * Closes the transport.\n     *\n     * @api private\n     */\n    doClose(fn) {\n        debug(\"closing\");\n        let closeTimeoutTimer;\n        if (this.dataReq) {\n            debug(\"aborting ongoing data request\");\n            this.dataReq.destroy();\n        }\n        const onClose = () => {\n            clearTimeout(closeTimeoutTimer);\n            fn();\n            this.onClose();\n        };\n        if (this.writable) {\n            debug(\"transport writable - closing right away\");\n            this.send([{ type: \"close\" }]);\n            onClose();\n        }\n        else if (this.discarded) {\n            debug(\"transport discarded - closing right away\");\n            onClose();\n        }\n        else {\n            debug(\"transport not writable - buffering orderly close\");\n            this.shouldClose = onClose;\n            closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);\n        }\n    }\n    /**\n     * Returns headers for a response.\n     *\n     * @param {http.IncomingMessage} request\n     * @param {Object} extra headers\n     * @api private\n     */\n    headers(req, headers) {\n        headers = headers || {};\n        // prevent XSS warnings on IE\n        // https://github.com/LearnBoost/socket.io/pull/1333\n        const ua = req.headers[\"user-agent\"];\n        if (ua && (~ua.indexOf(\";MSIE\") || ~ua.indexOf(\"Trident/\"))) {\n            headers[\"X-XSS-Protection\"] = \"0\";\n        }\n        this.emit(\"headers\", headers, req);\n        return headers;\n    }\n}\nexports.Polling = Polling;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParentNamespace = void 0;\n\nconst namespace_1 = require(\"./namespace\");\n\nclass ParentNamespace extends namespace_1.Namespace {\n  constructor(server) {\n    super(server, \"/_\" + ParentNamespace.count++);\n    this.children = new Set();\n  }\n  /**\n   * @private\n   */\n\n\n  _initAdapter() {\n    const broadcast = (packet, opts) => {\n      this.children.forEach(nsp => {\n        nsp.adapter.broadcast(packet, opts);\n      });\n    }; // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n\n\n    this.adapter = {\n      broadcast\n    };\n  }\n\n  emit(ev, ...args) {\n    this.children.forEach(nsp => {\n      nsp.emit(ev, ...args);\n    });\n    return true;\n  }\n\n  createChild(name) {\n    const namespace = new namespace_1.Namespace(this.server, name);\n    namespace._fns = this._fns.slice(0);\n    this.listeners(\"connect\").forEach(listener => namespace.on(\"connect\", listener));\n    this.listeners(\"connection\").forEach(listener => namespace.on(\"connection\", listener));\n    this.children.add(namespace);\n\n    this.server._nsps.set(name, namespace);\n\n    return namespace;\n  }\n\n  fetchSockets() {\n    // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n    // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n    // the behavior for namespaces created with a function is less clear\n    // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n    // may exist on one node but not exist on another (since it is created upon client connection)\n    throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n  }\n\n}\n\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;","map":{"version":3,"names":["Object","defineProperty","exports","value","ParentNamespace","namespace_1","require","Namespace","constructor","server","count","children","Set","_initAdapter","broadcast","packet","opts","forEach","nsp","adapter","emit","ev","args","createChild","name","namespace","_fns","slice","listeners","listener","on","add","_nsps","set","fetchSockets","Error"],"sources":["C:/Users/SystemForLinux/Desktop/f2/code/chat/chatangular/node_modules/socket.io/dist/parent-namespace.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParentNamespace = void 0;\nconst namespace_1 = require(\"./namespace\");\nclass ParentNamespace extends namespace_1.Namespace {\n    constructor(server) {\n        super(server, \"/_\" + ParentNamespace.count++);\n        this.children = new Set();\n    }\n    /**\n     * @private\n     */\n    _initAdapter() {\n        const broadcast = (packet, opts) => {\n            this.children.forEach((nsp) => {\n                nsp.adapter.broadcast(packet, opts);\n            });\n        };\n        // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?\n        this.adapter = { broadcast };\n    }\n    emit(ev, ...args) {\n        this.children.forEach((nsp) => {\n            nsp.emit(ev, ...args);\n        });\n        return true;\n    }\n    createChild(name) {\n        const namespace = new namespace_1.Namespace(this.server, name);\n        namespace._fns = this._fns.slice(0);\n        this.listeners(\"connect\").forEach((listener) => namespace.on(\"connect\", listener));\n        this.listeners(\"connection\").forEach((listener) => namespace.on(\"connection\", listener));\n        this.children.add(namespace);\n        this.server._nsps.set(name, namespace);\n        return namespace;\n    }\n    fetchSockets() {\n        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the\n        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but\n        // the behavior for namespaces created with a function is less clear\n        // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace\n        // may exist on one node but not exist on another (since it is created upon client connection)\n        throw new Error(\"fetchSockets() is not supported on parent namespaces\");\n    }\n}\nexports.ParentNamespace = ParentNamespace;\nParentNamespace.count = 0;\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0B,KAAK,CAA/B;;AACA,MAAMC,WAAW,GAAGC,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAMF,eAAN,SAA8BC,WAAW,CAACE,SAA1C,CAAoD;EAChDC,WAAW,CAACC,MAAD,EAAS;IAChB,MAAMA,MAAN,EAAc,OAAOL,eAAe,CAACM,KAAhB,EAArB;IACA,KAAKC,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;EACH;EACD;AACJ;AACA;;;EACIC,YAAY,GAAG;IACX,MAAMC,SAAS,GAAG,CAACC,MAAD,EAASC,IAAT,KAAkB;MAChC,KAAKL,QAAL,CAAcM,OAAd,CAAuBC,GAAD,IAAS;QAC3BA,GAAG,CAACC,OAAJ,CAAYL,SAAZ,CAAsBC,MAAtB,EAA8BC,IAA9B;MACH,CAFD;IAGH,CAJD,CADW,CAMX;;;IACA,KAAKG,OAAL,GAAe;MAAEL;IAAF,CAAf;EACH;;EACDM,IAAI,CAACC,EAAD,EAAK,GAAGC,IAAR,EAAc;IACd,KAAKX,QAAL,CAAcM,OAAd,CAAuBC,GAAD,IAAS;MAC3BA,GAAG,CAACE,IAAJ,CAASC,EAAT,EAAa,GAAGC,IAAhB;IACH,CAFD;IAGA,OAAO,IAAP;EACH;;EACDC,WAAW,CAACC,IAAD,EAAO;IACd,MAAMC,SAAS,GAAG,IAAIpB,WAAW,CAACE,SAAhB,CAA0B,KAAKE,MAA/B,EAAuCe,IAAvC,CAAlB;IACAC,SAAS,CAACC,IAAV,GAAiB,KAAKA,IAAL,CAAUC,KAAV,CAAgB,CAAhB,CAAjB;IACA,KAAKC,SAAL,CAAe,SAAf,EAA0BX,OAA1B,CAAmCY,QAAD,IAAcJ,SAAS,CAACK,EAAV,CAAa,SAAb,EAAwBD,QAAxB,CAAhD;IACA,KAAKD,SAAL,CAAe,YAAf,EAA6BX,OAA7B,CAAsCY,QAAD,IAAcJ,SAAS,CAACK,EAAV,CAAa,YAAb,EAA2BD,QAA3B,CAAnD;IACA,KAAKlB,QAAL,CAAcoB,GAAd,CAAkBN,SAAlB;;IACA,KAAKhB,MAAL,CAAYuB,KAAZ,CAAkBC,GAAlB,CAAsBT,IAAtB,EAA4BC,SAA5B;;IACA,OAAOA,SAAP;EACH;;EACDS,YAAY,GAAG;IACX;IACA;IACA;IACA;IACA;IACA,MAAM,IAAIC,KAAJ,CAAU,sDAAV,CAAN;EACH;;AAvC+C;;AAyCpDjC,OAAO,CAACE,eAAR,GAA0BA,eAA1B;AACAA,eAAe,CAACM,KAAhB,GAAwB,CAAxB"},"metadata":{},"sourceType":"script"}
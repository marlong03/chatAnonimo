{"ast":null,"code":"/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n'use strict';\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst {\n  randomFillSync\n} = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\n\nconst {\n  EMPTY_BUFFER\n} = require('./constants');\n\nconst {\n  isValidStatusCode\n} = require('./validation');\n\nconst {\n  mask: applyMask,\n  toBuffer\n} = require('./buffer-util');\n\nconst mask = Buffer.alloc(4);\n/**\n * HyBi Sender implementation.\n */\n\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n\n\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    let offset = options.mask ? 6 : 2;\n    let payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n    randomFillSync(mask, 0, 4);\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  doClose(data, mask, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x08,\n      mask,\n      readOnly: false\n    }), cb);\n  }\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x09,\n      mask,\n      readOnly\n    }), cb);\n  }\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x0a,\n      mask,\n      readOnly\n    }), cb);\n  }\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n\n\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n\n      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(buf, {\n        fin: options.fin,\n        rsv1: false,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      }), cb);\n    }\n  }\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    this._bufferedBytes += data.length;\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error('The socket was closed while data was being compressed');\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const callback = this._queue[i][4];\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= data.length;\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n\n\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n\n\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n\n    this._queue.push(params);\n  }\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n\n\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n\n      this._socket.write(list[0]);\n\n      this._socket.write(list[1], cb);\n\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n\n}\n\nmodule.exports = Sender;","map":{"version":3,"names":["net","require","tls","randomFillSync","PerMessageDeflate","EMPTY_BUFFER","isValidStatusCode","mask","applyMask","toBuffer","Buffer","alloc","Sender","constructor","socket","extensions","_extensions","_socket","_firstFragment","_compress","_bufferedBytes","_deflating","_queue","frame","data","options","merge","readOnly","offset","payloadLength","length","target","allocUnsafe","fin","opcode","rsv1","writeUInt16BE","writeUInt32BE","close","code","cb","buf","undefined","TypeError","byteLength","RangeError","write","set","enqueue","doClose","sendFrame","ping","doPing","pong","doPong","send","perMessageDeflate","extensionName","binary","compress","params","_isServer","_threshold","opts","dispatch","_","destroyed","err","Error","i","callback","dequeue","shift","Reflect","apply","slice","push","list","cork","uncork","module","exports"],"sources":["C:/Users/SystemForLinux/Desktop/f2/code/chat/chatangular/node_modules/ws/lib/sender.js"],"sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^net|tls$\" }] */\n\n'use strict';\n\nconst net = require('net');\nconst tls = require('tls');\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER } = require('./constants');\nconst { isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst mask = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    let offset = options.mask ? 6 : 2;\n    let payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    randomFillSync(mask, 0, 4);\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  doClose(data, mask, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x08,\n        mask,\n        readOnly: false\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x09,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (buf.length > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x0a,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(buf, {\n          fin: options.fin,\n          rsv1: false,\n          opcode,\n          mask: options.mask,\n          readOnly: toBuffer.readOnly\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += data.length;\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        if (typeof cb === 'function') cb(err);\n\n        for (let i = 0; i < this._queue.length; i++) {\n          const callback = this._queue[i][4];\n\n          if (typeof callback === 'function') callback(err);\n        }\n\n        return;\n      }\n\n      this._bufferedBytes -= data.length;\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
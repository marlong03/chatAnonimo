{"ast":null,"code":"/*!\n * base64id v0.1.0\n */\n\n/**\n * Module dependencies\n */\nvar crypto = require('crypto');\n/**\n * Constructor\n */\n\n\nvar Base64Id = function () {};\n/**\n * Get random bytes\n *\n * Uses a buffer if available, falls back to crypto.randomBytes\n */\n\n\nBase64Id.prototype.getRandomBytes = function (bytes) {\n  var BUFFER_SIZE = 4096;\n  var self = this;\n  bytes = bytes || 12;\n\n  if (bytes > BUFFER_SIZE) {\n    return crypto.randomBytes(bytes);\n  }\n\n  var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);\n  var threshold = parseInt(bytesInBuffer * 0.85);\n\n  if (!threshold) {\n    return crypto.randomBytes(bytes);\n  }\n\n  if (this.bytesBufferIndex == null) {\n    this.bytesBufferIndex = -1;\n  }\n\n  if (this.bytesBufferIndex == bytesInBuffer) {\n    this.bytesBuffer = null;\n    this.bytesBufferIndex = -1;\n  } // No buffered bytes available or index above threshold\n\n\n  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {\n    if (!this.isGeneratingBytes) {\n      this.isGeneratingBytes = true;\n      crypto.randomBytes(BUFFER_SIZE, function (err, bytes) {\n        self.bytesBuffer = bytes;\n        self.bytesBufferIndex = 0;\n        self.isGeneratingBytes = false;\n      });\n    } // Fall back to sync call when no buffered bytes are available\n\n\n    if (this.bytesBufferIndex == -1) {\n      return crypto.randomBytes(bytes);\n    }\n  }\n\n  var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));\n  this.bytesBufferIndex++;\n  return result;\n};\n/**\n * Generates a base64 id\n *\n * (Original version from socket.io <http://socket.io>)\n */\n\n\nBase64Id.prototype.generateId = function () {\n  var rand = Buffer.alloc(15); // multiple of 3 for base64\n\n  if (!rand.writeInt32BE) {\n    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();\n  }\n\n  this.sequenceNumber = this.sequenceNumber + 1 | 0;\n  rand.writeInt32BE(this.sequenceNumber, 11);\n\n  if (crypto.randomBytes) {\n    this.getRandomBytes(12).copy(rand);\n  } else {\n    // not secure for node 0.4\n    [0, 4, 8].forEach(function (i) {\n      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);\n    });\n  }\n\n  return rand.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n};\n/**\n * Export\n */\n\n\nexports = module.exports = new Base64Id();","map":{"version":3,"names":["crypto","require","Base64Id","prototype","getRandomBytes","bytes","BUFFER_SIZE","self","randomBytes","bytesInBuffer","parseInt","threshold","bytesBufferIndex","bytesBuffer","isGeneratingBytes","err","result","slice","generateId","rand","Buffer","alloc","writeInt32BE","Math","abs","random","Date","now","toString","sequenceNumber","copy","forEach","i","pow","replace","exports","module"],"sources":["C:/Users/SystemForLinux/Desktop/f2/code/chat/chatangular/node_modules/base64id/lib/base64id.js"],"sourcesContent":["/*!\n * base64id v0.1.0\n */\n\n/**\n * Module dependencies\n */\n\nvar crypto = require('crypto');\n\n/**\n * Constructor\n */\n\nvar Base64Id = function() { };\n\n/**\n * Get random bytes\n *\n * Uses a buffer if available, falls back to crypto.randomBytes\n */\n\nBase64Id.prototype.getRandomBytes = function(bytes) {\n\n  var BUFFER_SIZE = 4096\n  var self = this;  \n  \n  bytes = bytes || 12;\n\n  if (bytes > BUFFER_SIZE) {\n    return crypto.randomBytes(bytes);\n  }\n  \n  var bytesInBuffer = parseInt(BUFFER_SIZE/bytes);\n  var threshold = parseInt(bytesInBuffer*0.85);\n\n  if (!threshold) {\n    return crypto.randomBytes(bytes);\n  }\n\n  if (this.bytesBufferIndex == null) {\n     this.bytesBufferIndex = -1;\n  }\n\n  if (this.bytesBufferIndex == bytesInBuffer) {\n    this.bytesBuffer = null;\n    this.bytesBufferIndex = -1;\n  }\n\n  // No buffered bytes available or index above threshold\n  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {\n     \n    if (!this.isGeneratingBytes) {\n      this.isGeneratingBytes = true;\n      crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {\n        self.bytesBuffer = bytes;\n        self.bytesBufferIndex = 0;\n        self.isGeneratingBytes = false;\n      }); \n    }\n    \n    // Fall back to sync call when no buffered bytes are available\n    if (this.bytesBufferIndex == -1) {\n      return crypto.randomBytes(bytes);\n    }\n  }\n  \n  var result = this.bytesBuffer.slice(bytes*this.bytesBufferIndex, bytes*(this.bytesBufferIndex+1)); \n  this.bytesBufferIndex++; \n  \n  return result;\n}\n\n/**\n * Generates a base64 id\n *\n * (Original version from socket.io <http://socket.io>)\n */\n\nBase64Id.prototype.generateId = function () {\n  var rand = Buffer.alloc(15); // multiple of 3 for base64\n  if (!rand.writeInt32BE) {\n    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()\n      + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();\n  }\n  this.sequenceNumber = (this.sequenceNumber + 1) | 0;\n  rand.writeInt32BE(this.sequenceNumber, 11);\n  if (crypto.randomBytes) {\n    this.getRandomBytes(12).copy(rand);\n  } else {\n    // not secure for node 0.4\n    [0, 4, 8].forEach(function(i) {\n      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);\n    });\n  }\n  return rand.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n};\n\n/**\n * Export\n */\n\nexports = module.exports = new Base64Id();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}
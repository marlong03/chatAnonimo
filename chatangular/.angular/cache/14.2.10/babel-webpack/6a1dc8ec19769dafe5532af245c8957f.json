{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Socket = void 0;\n\nconst events_1 = require(\"events\");\n\nconst debug_1 = require(\"debug\");\n\nconst timers_1 = require(\"timers\");\n\nconst debug = (0, debug_1.default)(\"engine:socket\");\n\nclass Socket extends events_1.EventEmitter {\n  /**\n   * Client class (abstract).\n   *\n   * @api private\n   */\n  constructor(id, server, transport, req, protocol) {\n    super();\n    this.id = id;\n    this.server = server;\n    this.upgrading = false;\n    this.upgraded = false;\n    this.readyState = \"opening\";\n    this.writeBuffer = [];\n    this.packetsFn = [];\n    this.sentCallbackFn = [];\n    this.cleanupFn = [];\n    this.request = req;\n    this.protocol = protocol; // Cache IP since it might not be in the req later\n\n    if (req.websocket && req.websocket._socket) {\n      this.remoteAddress = req.websocket._socket.remoteAddress;\n    } else {\n      this.remoteAddress = req.connection.remoteAddress;\n    }\n\n    this.checkIntervalTimer = null;\n    this.upgradeTimeoutTimer = null;\n    this.pingTimeoutTimer = null;\n    this.pingIntervalTimer = null;\n    this.setTransport(transport);\n    this.onOpen();\n  }\n\n  get readyState() {\n    return this._readyState;\n  }\n\n  set readyState(state) {\n    debug(\"readyState updated from %s to %s\", this._readyState, state);\n    this._readyState = state;\n  }\n  /**\n   * Called upon transport considered open.\n   *\n   * @api private\n   */\n\n\n  onOpen() {\n    this.readyState = \"open\"; // sends an `open` packet\n\n    this.transport.sid = this.id;\n    this.sendPacket(\"open\", JSON.stringify({\n      sid: this.id,\n      upgrades: this.getAvailableUpgrades(),\n      pingInterval: this.server.opts.pingInterval,\n      pingTimeout: this.server.opts.pingTimeout,\n      maxPayload: this.server.opts.maxHttpBufferSize\n    }));\n\n    if (this.server.opts.initialPacket) {\n      this.sendPacket(\"message\", this.server.opts.initialPacket);\n    }\n\n    this.emit(\"open\");\n\n    if (this.protocol === 3) {\n      // in protocol v3, the client sends a ping, and the server answers with a pong\n      this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n    } else {\n      // in protocol v4, the server sends a ping, and the client answers with a pong\n      this.schedulePing();\n    }\n  }\n  /**\n   * Called upon transport packet.\n   *\n   * @param {Object} packet\n   * @api private\n   */\n\n\n  onPacket(packet) {\n    if (\"open\" !== this.readyState) {\n      return debug(\"packet received with closed socket\");\n    } // export packet event\n\n\n    debug(`received packet ${packet.type}`);\n    this.emit(\"packet\", packet); // Reset ping timeout on any packet, incoming data is a good sign of\n    // other side's liveness\n\n    this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n\n    switch (packet.type) {\n      case \"ping\":\n        if (this.transport.protocol !== 3) {\n          this.onError(\"invalid heartbeat direction\");\n          return;\n        }\n\n        debug(\"got ping\");\n        this.sendPacket(\"pong\");\n        this.emit(\"heartbeat\");\n        break;\n\n      case \"pong\":\n        if (this.transport.protocol === 3) {\n          this.onError(\"invalid heartbeat direction\");\n          return;\n        }\n\n        debug(\"got pong\");\n        this.pingIntervalTimer.refresh();\n        this.emit(\"heartbeat\");\n        break;\n\n      case \"error\":\n        this.onClose(\"parse error\");\n        break;\n\n      case \"message\":\n        this.emit(\"data\", packet.data);\n        this.emit(\"message\", packet.data);\n        break;\n    }\n  }\n  /**\n   * Called upon transport error.\n   *\n   * @param {Error} error object\n   * @api private\n   */\n\n\n  onError(err) {\n    debug(\"transport error\");\n    this.onClose(\"transport error\", err);\n  }\n  /**\n   * Pings client every `this.pingInterval` and expects response\n   * within `this.pingTimeout` or closes connection.\n   *\n   * @api private\n   */\n\n\n  schedulePing() {\n    this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {\n      debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n      this.sendPacket(\"ping\");\n      this.resetPingTimeout(this.server.opts.pingTimeout);\n    }, this.server.opts.pingInterval);\n  }\n  /**\n   * Resets ping timeout.\n   *\n   * @api private\n   */\n\n\n  resetPingTimeout(timeout) {\n    (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n    this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {\n      if (this.readyState === \"closed\") return;\n      this.onClose(\"ping timeout\");\n    }, timeout);\n  }\n  /**\n   * Attaches handlers for the given transport.\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n\n\n  setTransport(transport) {\n    const onError = this.onError.bind(this);\n    const onPacket = this.onPacket.bind(this);\n    const flush = this.flush.bind(this);\n    const onClose = this.onClose.bind(this, \"transport close\");\n    this.transport = transport;\n    this.transport.once(\"error\", onError);\n    this.transport.on(\"packet\", onPacket);\n    this.transport.on(\"drain\", flush);\n    this.transport.once(\"close\", onClose); // this function will manage packet events (also message callbacks)\n\n    this.setupSendCallback();\n    this.cleanupFn.push(function () {\n      transport.removeListener(\"error\", onError);\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"drain\", flush);\n      transport.removeListener(\"close\", onClose);\n    });\n  }\n  /**\n   * Upgrades socket to the given transport\n   *\n   * @param {Transport} transport\n   * @api private\n   */\n\n\n  maybeUpgrade(transport) {\n    debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n    this.upgrading = true; // set transport upgrade timer\n\n    this.upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {\n      debug(\"client did not complete upgrade - closing transport\");\n      cleanup();\n\n      if (\"open\" === transport.readyState) {\n        transport.close();\n      }\n    }, this.server.opts.upgradeTimeout);\n\n    const onPacket = packet => {\n      if (\"ping\" === packet.type && \"probe\" === packet.data) {\n        debug(\"got probe ping packet, sending pong\");\n        transport.send([{\n          type: \"pong\",\n          data: \"probe\"\n        }]);\n        this.emit(\"upgrading\", transport);\n        clearInterval(this.checkIntervalTimer);\n        this.checkIntervalTimer = setInterval(check, 100);\n      } else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n        debug(\"got upgrade packet - upgrading\");\n        cleanup();\n        this.transport.discard();\n        this.upgraded = true;\n        this.clearTransport();\n        this.setTransport(transport);\n        this.emit(\"upgrade\", transport);\n        this.flush();\n\n        if (this.readyState === \"closing\") {\n          transport.close(() => {\n            this.onClose(\"forced close\");\n          });\n        }\n      } else {\n        cleanup();\n        transport.close();\n      }\n    }; // we force a polling cycle to ensure a fast upgrade\n\n\n    const check = () => {\n      if (\"polling\" === this.transport.name && this.transport.writable) {\n        debug(\"writing a noop packet to polling for fast upgrade\");\n        this.transport.send([{\n          type: \"noop\"\n        }]);\n      }\n    };\n\n    const cleanup = () => {\n      this.upgrading = false;\n      clearInterval(this.checkIntervalTimer);\n      this.checkIntervalTimer = null;\n      (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer);\n      this.upgradeTimeoutTimer = null;\n      transport.removeListener(\"packet\", onPacket);\n      transport.removeListener(\"close\", onTransportClose);\n      transport.removeListener(\"error\", onError);\n      this.removeListener(\"close\", onClose);\n    };\n\n    const onError = err => {\n      debug(\"client did not complete upgrade - %s\", err);\n      cleanup();\n      transport.close();\n      transport = null;\n    };\n\n    const onTransportClose = () => {\n      onError(\"transport closed\");\n    };\n\n    const onClose = () => {\n      onError(\"socket closed\");\n    };\n\n    transport.on(\"packet\", onPacket);\n    transport.once(\"close\", onTransportClose);\n    transport.once(\"error\", onError);\n    this.once(\"close\", onClose);\n  }\n  /**\n   * Clears listeners and timers associated with current transport.\n   *\n   * @api private\n   */\n\n\n  clearTransport() {\n    let cleanup;\n    const toCleanUp = this.cleanupFn.length;\n\n    for (let i = 0; i < toCleanUp; i++) {\n      cleanup = this.cleanupFn.shift();\n      cleanup();\n    } // silence further transport errors and prevent uncaught exceptions\n\n\n    this.transport.on(\"error\", function () {\n      debug(\"error triggered by discarded transport\");\n    }); // ensure transport won't stay open\n\n    this.transport.close();\n    (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n  }\n  /**\n   * Called upon transport considered closed.\n   * Possible reasons: `ping timeout`, `client error`, `parse error`,\n   * `transport error`, `server close`, `transport close`\n   */\n\n\n  onClose(reason, description) {\n    if (\"closed\" !== this.readyState) {\n      this.readyState = \"closed\"; // clear timers\n\n      (0, timers_1.clearTimeout)(this.pingIntervalTimer);\n      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n      clearInterval(this.checkIntervalTimer);\n      this.checkIntervalTimer = null;\n      (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer); // clean writeBuffer in next tick, so developers can still\n      // grab the writeBuffer on 'close' event\n\n      process.nextTick(() => {\n        this.writeBuffer = [];\n      });\n      this.packetsFn = [];\n      this.sentCallbackFn = [];\n      this.clearTransport();\n      this.emit(\"close\", reason, description);\n    }\n  }\n  /**\n   * Setup and manage send callback\n   *\n   * @api private\n   */\n\n\n  setupSendCallback() {\n    // the message was sent successfully, execute the callback\n    const onDrain = () => {\n      if (this.sentCallbackFn.length > 0) {\n        const seqFn = this.sentCallbackFn.splice(0, 1)[0];\n\n        if (\"function\" === typeof seqFn) {\n          debug(\"executing send callback\");\n          seqFn(this.transport);\n        } else if (Array.isArray(seqFn)) {\n          debug(\"executing batch send callback\");\n          const l = seqFn.length;\n          let i = 0;\n\n          for (; i < l; i++) {\n            if (\"function\" === typeof seqFn[i]) {\n              seqFn[i](this.transport);\n            }\n          }\n        }\n      }\n    };\n\n    this.transport.on(\"drain\", onDrain);\n    this.cleanupFn.push(() => {\n      this.transport.removeListener(\"drain\", onDrain);\n    });\n  }\n  /**\n   * Sends a message packet.\n   *\n   * @param {Object} data\n   * @param {Object} options\n   * @param {Function} callback\n   * @return {Socket} for chaining\n   * @api public\n   */\n\n\n  send(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n\n  write(data, options, callback) {\n    this.sendPacket(\"message\", data, options, callback);\n    return this;\n  }\n  /**\n   * Sends a packet.\n   *\n   * @param {String} type - packet type\n   * @param {String} data\n   * @param {Object} options\n   * @param {Function} callback\n   *\n   * @api private\n   */\n\n\n  sendPacket(type, data, options, callback) {\n    if (\"function\" === typeof options) {\n      callback = options;\n      options = null;\n    }\n\n    options = options || {};\n    options.compress = false !== options.compress;\n\n    if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n      debug('sending packet \"%s\" (%s)', type, data);\n      const packet = {\n        type,\n        options\n      };\n      if (data) packet.data = data; // exports packetCreate event\n\n      this.emit(\"packetCreate\", packet);\n      this.writeBuffer.push(packet); // add send callback to object, if defined\n\n      if (callback) this.packetsFn.push(callback);\n      this.flush();\n    }\n  }\n  /**\n   * Attempts to flush the packets buffer.\n   *\n   * @api private\n   */\n\n\n  flush() {\n    if (\"closed\" !== this.readyState && this.transport.writable && this.writeBuffer.length) {\n      debug(\"flushing buffer to transport\");\n      this.emit(\"flush\", this.writeBuffer);\n      this.server.emit(\"flush\", this, this.writeBuffer);\n      const wbuf = this.writeBuffer;\n      this.writeBuffer = [];\n\n      if (!this.transport.supportsFraming) {\n        this.sentCallbackFn.push(this.packetsFn);\n      } else {\n        this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n      }\n\n      this.packetsFn = [];\n      this.transport.send(wbuf);\n      this.emit(\"drain\");\n      this.server.emit(\"drain\", this);\n    }\n  }\n  /**\n   * Get available upgrades for this socket.\n   *\n   * @api private\n   */\n\n\n  getAvailableUpgrades() {\n    const availableUpgrades = [];\n    const allUpgrades = this.server.upgrades(this.transport.name);\n    let i = 0;\n    const l = allUpgrades.length;\n\n    for (; i < l; ++i) {\n      const upg = allUpgrades[i];\n\n      if (this.server.opts.transports.indexOf(upg) !== -1) {\n        availableUpgrades.push(upg);\n      }\n    }\n\n    return availableUpgrades;\n  }\n  /**\n   * Closes the socket and underlying transport.\n   *\n   * @param {Boolean} discard - optional, discard the transport\n   * @return {Socket} for chaining\n   * @api public\n   */\n\n\n  close(discard) {\n    if (\"open\" !== this.readyState) return;\n    this.readyState = \"closing\";\n\n    if (this.writeBuffer.length) {\n      this.once(\"drain\", this.closeTransport.bind(this, discard));\n      return;\n    }\n\n    this.closeTransport(discard);\n  }\n  /**\n   * Closes the underlying transport.\n   *\n   * @param {Boolean} discard\n   * @api private\n   */\n\n\n  closeTransport(discard) {\n    if (discard) this.transport.discard();\n    this.transport.close(this.onClose.bind(this, \"forced close\"));\n  }\n\n}\n\nexports.Socket = Socket;","map":{"version":3,"names":["Object","defineProperty","exports","value","Socket","events_1","require","debug_1","timers_1","debug","default","EventEmitter","constructor","id","server","transport","req","protocol","upgrading","upgraded","readyState","writeBuffer","packetsFn","sentCallbackFn","cleanupFn","request","websocket","_socket","remoteAddress","connection","checkIntervalTimer","upgradeTimeoutTimer","pingTimeoutTimer","pingIntervalTimer","setTransport","onOpen","_readyState","state","sid","sendPacket","JSON","stringify","upgrades","getAvailableUpgrades","pingInterval","opts","pingTimeout","maxPayload","maxHttpBufferSize","initialPacket","emit","resetPingTimeout","schedulePing","onPacket","packet","type","onError","refresh","onClose","data","err","setTimeout","timeout","clearTimeout","bind","flush","once","on","setupSendCallback","push","removeListener","maybeUpgrade","name","cleanup","close","upgradeTimeout","send","clearInterval","setInterval","check","discard","clearTransport","writable","onTransportClose","toCleanUp","length","i","shift","reason","description","process","nextTick","onDrain","seqFn","splice","Array","isArray","l","options","callback","write","compress","wbuf","supportsFraming","apply","availableUpgrades","allUpgrades","upg","transports","indexOf","closeTransport"],"sources":["C:/Users/SystemForLinux/Desktop/f2/code/chat/chatangular/node_modules/engine.io/build/socket.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Socket = void 0;\nconst events_1 = require(\"events\");\nconst debug_1 = require(\"debug\");\nconst timers_1 = require(\"timers\");\nconst debug = (0, debug_1.default)(\"engine:socket\");\nclass Socket extends events_1.EventEmitter {\n    /**\n     * Client class (abstract).\n     *\n     * @api private\n     */\n    constructor(id, server, transport, req, protocol) {\n        super();\n        this.id = id;\n        this.server = server;\n        this.upgrading = false;\n        this.upgraded = false;\n        this.readyState = \"opening\";\n        this.writeBuffer = [];\n        this.packetsFn = [];\n        this.sentCallbackFn = [];\n        this.cleanupFn = [];\n        this.request = req;\n        this.protocol = protocol;\n        // Cache IP since it might not be in the req later\n        if (req.websocket && req.websocket._socket) {\n            this.remoteAddress = req.websocket._socket.remoteAddress;\n        }\n        else {\n            this.remoteAddress = req.connection.remoteAddress;\n        }\n        this.checkIntervalTimer = null;\n        this.upgradeTimeoutTimer = null;\n        this.pingTimeoutTimer = null;\n        this.pingIntervalTimer = null;\n        this.setTransport(transport);\n        this.onOpen();\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    set readyState(state) {\n        debug(\"readyState updated from %s to %s\", this._readyState, state);\n        this._readyState = state;\n    }\n    /**\n     * Called upon transport considered open.\n     *\n     * @api private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        // sends an `open` packet\n        this.transport.sid = this.id;\n        this.sendPacket(\"open\", JSON.stringify({\n            sid: this.id,\n            upgrades: this.getAvailableUpgrades(),\n            pingInterval: this.server.opts.pingInterval,\n            pingTimeout: this.server.opts.pingTimeout,\n            maxPayload: this.server.opts.maxHttpBufferSize\n        }));\n        if (this.server.opts.initialPacket) {\n            this.sendPacket(\"message\", this.server.opts.initialPacket);\n        }\n        this.emit(\"open\");\n        if (this.protocol === 3) {\n            // in protocol v3, the client sends a ping, and the server answers with a pong\n            this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n        }\n        else {\n            // in protocol v4, the server sends a ping, and the client answers with a pong\n            this.schedulePing();\n        }\n    }\n    /**\n     * Called upon transport packet.\n     *\n     * @param {Object} packet\n     * @api private\n     */\n    onPacket(packet) {\n        if (\"open\" !== this.readyState) {\n            return debug(\"packet received with closed socket\");\n        }\n        // export packet event\n        debug(`received packet ${packet.type}`);\n        this.emit(\"packet\", packet);\n        // Reset ping timeout on any packet, incoming data is a good sign of\n        // other side's liveness\n        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);\n        switch (packet.type) {\n            case \"ping\":\n                if (this.transport.protocol !== 3) {\n                    this.onError(\"invalid heartbeat direction\");\n                    return;\n                }\n                debug(\"got ping\");\n                this.sendPacket(\"pong\");\n                this.emit(\"heartbeat\");\n                break;\n            case \"pong\":\n                if (this.transport.protocol === 3) {\n                    this.onError(\"invalid heartbeat direction\");\n                    return;\n                }\n                debug(\"got pong\");\n                this.pingIntervalTimer.refresh();\n                this.emit(\"heartbeat\");\n                break;\n            case \"error\":\n                this.onClose(\"parse error\");\n                break;\n            case \"message\":\n                this.emit(\"data\", packet.data);\n                this.emit(\"message\", packet.data);\n                break;\n        }\n    }\n    /**\n     * Called upon transport error.\n     *\n     * @param {Error} error object\n     * @api private\n     */\n    onError(err) {\n        debug(\"transport error\");\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Pings client every `this.pingInterval` and expects response\n     * within `this.pingTimeout` or closes connection.\n     *\n     * @api private\n     */\n    schedulePing() {\n        this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {\n            debug(\"writing ping packet - expecting pong within %sms\", this.server.opts.pingTimeout);\n            this.sendPacket(\"ping\");\n            this.resetPingTimeout(this.server.opts.pingTimeout);\n        }, this.server.opts.pingInterval);\n    }\n    /**\n     * Resets ping timeout.\n     *\n     * @api private\n     */\n    resetPingTimeout(timeout) {\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = (0, timers_1.setTimeout)(() => {\n            if (this.readyState === \"closed\")\n                return;\n            this.onClose(\"ping timeout\");\n        }, timeout);\n    }\n    /**\n     * Attaches handlers for the given transport.\n     *\n     * @param {Transport} transport\n     * @api private\n     */\n    setTransport(transport) {\n        const onError = this.onError.bind(this);\n        const onPacket = this.onPacket.bind(this);\n        const flush = this.flush.bind(this);\n        const onClose = this.onClose.bind(this, \"transport close\");\n        this.transport = transport;\n        this.transport.once(\"error\", onError);\n        this.transport.on(\"packet\", onPacket);\n        this.transport.on(\"drain\", flush);\n        this.transport.once(\"close\", onClose);\n        // this function will manage packet events (also message callbacks)\n        this.setupSendCallback();\n        this.cleanupFn.push(function () {\n            transport.removeListener(\"error\", onError);\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"drain\", flush);\n            transport.removeListener(\"close\", onClose);\n        });\n    }\n    /**\n     * Upgrades socket to the given transport\n     *\n     * @param {Transport} transport\n     * @api private\n     */\n    maybeUpgrade(transport) {\n        debug('might upgrade socket transport from \"%s\" to \"%s\"', this.transport.name, transport.name);\n        this.upgrading = true;\n        // set transport upgrade timer\n        this.upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {\n            debug(\"client did not complete upgrade - closing transport\");\n            cleanup();\n            if (\"open\" === transport.readyState) {\n                transport.close();\n            }\n        }, this.server.opts.upgradeTimeout);\n        const onPacket = packet => {\n            if (\"ping\" === packet.type && \"probe\" === packet.data) {\n                debug(\"got probe ping packet, sending pong\");\n                transport.send([{ type: \"pong\", data: \"probe\" }]);\n                this.emit(\"upgrading\", transport);\n                clearInterval(this.checkIntervalTimer);\n                this.checkIntervalTimer = setInterval(check, 100);\n            }\n            else if (\"upgrade\" === packet.type && this.readyState !== \"closed\") {\n                debug(\"got upgrade packet - upgrading\");\n                cleanup();\n                this.transport.discard();\n                this.upgraded = true;\n                this.clearTransport();\n                this.setTransport(transport);\n                this.emit(\"upgrade\", transport);\n                this.flush();\n                if (this.readyState === \"closing\") {\n                    transport.close(() => {\n                        this.onClose(\"forced close\");\n                    });\n                }\n            }\n            else {\n                cleanup();\n                transport.close();\n            }\n        };\n        // we force a polling cycle to ensure a fast upgrade\n        const check = () => {\n            if (\"polling\" === this.transport.name && this.transport.writable) {\n                debug(\"writing a noop packet to polling for fast upgrade\");\n                this.transport.send([{ type: \"noop\" }]);\n            }\n        };\n        const cleanup = () => {\n            this.upgrading = false;\n            clearInterval(this.checkIntervalTimer);\n            this.checkIntervalTimer = null;\n            (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer);\n            this.upgradeTimeoutTimer = null;\n            transport.removeListener(\"packet\", onPacket);\n            transport.removeListener(\"close\", onTransportClose);\n            transport.removeListener(\"error\", onError);\n            this.removeListener(\"close\", onClose);\n        };\n        const onError = err => {\n            debug(\"client did not complete upgrade - %s\", err);\n            cleanup();\n            transport.close();\n            transport = null;\n        };\n        const onTransportClose = () => {\n            onError(\"transport closed\");\n        };\n        const onClose = () => {\n            onError(\"socket closed\");\n        };\n        transport.on(\"packet\", onPacket);\n        transport.once(\"close\", onTransportClose);\n        transport.once(\"error\", onError);\n        this.once(\"close\", onClose);\n    }\n    /**\n     * Clears listeners and timers associated with current transport.\n     *\n     * @api private\n     */\n    clearTransport() {\n        let cleanup;\n        const toCleanUp = this.cleanupFn.length;\n        for (let i = 0; i < toCleanUp; i++) {\n            cleanup = this.cleanupFn.shift();\n            cleanup();\n        }\n        // silence further transport errors and prevent uncaught exceptions\n        this.transport.on(\"error\", function () {\n            debug(\"error triggered by discarded transport\");\n        });\n        // ensure transport won't stay open\n        this.transport.close();\n        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n    }\n    /**\n     * Called upon transport considered closed.\n     * Possible reasons: `ping timeout`, `client error`, `parse error`,\n     * `transport error`, `server close`, `transport close`\n     */\n    onClose(reason, description) {\n        if (\"closed\" !== this.readyState) {\n            this.readyState = \"closed\";\n            // clear timers\n            (0, timers_1.clearTimeout)(this.pingIntervalTimer);\n            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);\n            clearInterval(this.checkIntervalTimer);\n            this.checkIntervalTimer = null;\n            (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer);\n            // clean writeBuffer in next tick, so developers can still\n            // grab the writeBuffer on 'close' event\n            process.nextTick(() => {\n                this.writeBuffer = [];\n            });\n            this.packetsFn = [];\n            this.sentCallbackFn = [];\n            this.clearTransport();\n            this.emit(\"close\", reason, description);\n        }\n    }\n    /**\n     * Setup and manage send callback\n     *\n     * @api private\n     */\n    setupSendCallback() {\n        // the message was sent successfully, execute the callback\n        const onDrain = () => {\n            if (this.sentCallbackFn.length > 0) {\n                const seqFn = this.sentCallbackFn.splice(0, 1)[0];\n                if (\"function\" === typeof seqFn) {\n                    debug(\"executing send callback\");\n                    seqFn(this.transport);\n                }\n                else if (Array.isArray(seqFn)) {\n                    debug(\"executing batch send callback\");\n                    const l = seqFn.length;\n                    let i = 0;\n                    for (; i < l; i++) {\n                        if (\"function\" === typeof seqFn[i]) {\n                            seqFn[i](this.transport);\n                        }\n                    }\n                }\n            }\n        };\n        this.transport.on(\"drain\", onDrain);\n        this.cleanupFn.push(() => {\n            this.transport.removeListener(\"drain\", onDrain);\n        });\n    }\n    /**\n     * Sends a message packet.\n     *\n     * @param {Object} data\n     * @param {Object} options\n     * @param {Function} callback\n     * @return {Socket} for chaining\n     * @api public\n     */\n    send(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    write(data, options, callback) {\n        this.sendPacket(\"message\", data, options, callback);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type - packet type\n     * @param {String} data\n     * @param {Object} options\n     * @param {Function} callback\n     *\n     * @api private\n     */\n    sendPacket(type, data, options, callback) {\n        if (\"function\" === typeof options) {\n            callback = options;\n            options = null;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        if (\"closing\" !== this.readyState && \"closed\" !== this.readyState) {\n            debug('sending packet \"%s\" (%s)', type, data);\n            const packet = {\n                type,\n                options\n            };\n            if (data)\n                packet.data = data;\n            // exports packetCreate event\n            this.emit(\"packetCreate\", packet);\n            this.writeBuffer.push(packet);\n            // add send callback to object, if defined\n            if (callback)\n                this.packetsFn.push(callback);\n            this.flush();\n        }\n    }\n    /**\n     * Attempts to flush the packets buffer.\n     *\n     * @api private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            this.writeBuffer.length) {\n            debug(\"flushing buffer to transport\");\n            this.emit(\"flush\", this.writeBuffer);\n            this.server.emit(\"flush\", this, this.writeBuffer);\n            const wbuf = this.writeBuffer;\n            this.writeBuffer = [];\n            if (!this.transport.supportsFraming) {\n                this.sentCallbackFn.push(this.packetsFn);\n            }\n            else {\n                this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);\n            }\n            this.packetsFn = [];\n            this.transport.send(wbuf);\n            this.emit(\"drain\");\n            this.server.emit(\"drain\", this);\n        }\n    }\n    /**\n     * Get available upgrades for this socket.\n     *\n     * @api private\n     */\n    getAvailableUpgrades() {\n        const availableUpgrades = [];\n        const allUpgrades = this.server.upgrades(this.transport.name);\n        let i = 0;\n        const l = allUpgrades.length;\n        for (; i < l; ++i) {\n            const upg = allUpgrades[i];\n            if (this.server.opts.transports.indexOf(upg) !== -1) {\n                availableUpgrades.push(upg);\n            }\n        }\n        return availableUpgrades;\n    }\n    /**\n     * Closes the socket and underlying transport.\n     *\n     * @param {Boolean} discard - optional, discard the transport\n     * @return {Socket} for chaining\n     * @api public\n     */\n    close(discard) {\n        if (\"open\" !== this.readyState)\n            return;\n        this.readyState = \"closing\";\n        if (this.writeBuffer.length) {\n            this.once(\"drain\", this.closeTransport.bind(this, discard));\n            return;\n        }\n        this.closeTransport(discard);\n    }\n    /**\n     * Closes the underlying transport.\n     *\n     * @param {Boolean} discard\n     * @api private\n     */\n    closeTransport(discard) {\n        if (discard)\n            this.transport.discard();\n        this.transport.close(this.onClose.bind(this, \"forced close\"));\n    }\n}\nexports.Socket = Socket;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}